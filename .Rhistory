library(readr)
install.packages("readr")
install.package(readr)
install.packages("readr")
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("tidyverse")
library(readr)
library(ggplot2)
library(tidyverse)
dat <- read_csv("./dataset/bdiag.csv")
dat['diag_'] <- as.numeric(dat[c('diagnosis')] == 'M')
#View(dat)
dat_m <- dat[c('diag_', 'radius_mean', 'texture_mean')]
p1 = ggplot(data = dat, aes(fill = diagnosis, y = radius_mean))+geom_boxplot()
p2 = ggplot(data = dat, aes(fill = diagnosis, y = texture_mean))+geom_boxplot()
p1
p2
dat_m['randu'] <- c(runif(nrow(dat), 0, 1))
#training data
train_dat = dat_m %>% filter(randu <= 0.1)
#test data
test_dat = dat_m %>% filter(randu >= 0.1)
#train model
model <- glm (diag_ ~ radius_mean + texture_mean, data = train_dat, family = binomial)
summary(model)
library(readr)
library(ggplot2)
library(tidyverse)
library(lattice)
library(ROCR)
dat <- read_csv("./dataset/bdiag.csv")
dat['diag_'] <- as.numeric(dat[c('diagnosis')] == 'M')
#View(dat)
dat_m <- dat[c('diag_', 'radius_mean', 'texture_mean')]
p1 = ggplot(data = dat, aes(fill = diagnosis, y = radius_mean))+geom_boxplot()
p2 = ggplot(data = dat, aes(fill = diagnosis, y = texture_mean))+geom_boxplot()
p1
p2
#removing outliers
Q_r = quantile(dat$radius_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_r = IQR(dat$radius_mean)
up_r <-  Q_r[2]+1.5*iqr_r # Upper Range for radius
low_r<- Q_r[1]-1.5*iqr_r # Lower Range for radius
Q_t = quantile(dat$texture_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_t = IQR(dat$texture_mean)
up_t <-  Q_t[2]+1.5*iqr_t # Upper Range for texture
low_t<- Q_t[1]-1.5*iqr_t # Lower Range for texture
dat_m<- subset(dat_m, dat$radius_mean > (low_r) & dat$radius_mean < (up_r) & dat$texture_mean > (low_t) & dat$texture_mean < (up_t))
#split data
dat_m['randu'] <- c(runif(nrow(dat_m), 0, 1))
#training data
train_dat = dat_m %>% filter(randu <= 0.1)
#test data
test_dat = dat_m %>% filter(randu >= 0.1)
#train model
model <- glm (diag_ ~ radius_mean + texture_mean, data = train_dat, family = binomial)
#check coefficients
summary(model)
sprintf('Odds ratio : \n %s', paste(exp(coef(model)), collapse = ", ")) %>% writeLines()
#scatterplot
slope <- coef(model)[2]/(-coef(model)[3])
intercept <- coef(model)[1]/(-coef(model)[3])
xyplot(texture_mean ~ radius_mean , data = test_dat, groups = diag_,
panel=function(...){
panel.xyplot(...)
panel.abline(intercept , slope)
panel.grid(...)
})
#roc curve
pred_y = predict.glm(object = model, newdata = test_dat, type = "response")
pred_y
pred = prediction(predictions = pred_y, labels = test_dat$diag_)
roc_plot <- performance(pred,"tpr","fpr")
plot(roc_plot ,colorize=FALSE)
auc <- performance(pred, measure = "auc")
sprintf("AUC : %f", auc@y.values[[1]])
library(ROCR)
install.packages("ROCR")
library(readr)
library(ggplot2)
library(tidyverse)
library(lattice)
library(ROCR)
dat <- read_csv("./dataset/bdiag.csv")
dat['diag_'] <- as.numeric(dat[c('diagnosis')] == 'M')
#View(dat)
dat_m <- dat[c('diag_', 'radius_mean', 'texture_mean')]
p1 = ggplot(data = dat, aes(fill = diagnosis, y = radius_mean))+geom_boxplot()
p2 = ggplot(data = dat, aes(fill = diagnosis, y = texture_mean))+geom_boxplot()
p1
p2
#removing outliers
Q_r = quantile(dat$radius_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_r = IQR(dat$radius_mean)
up_r <-  Q_r[2]+1.5*iqr_r # Upper Range for radius
low_r<- Q_r[1]-1.5*iqr_r # Lower Range for radius
Q_t = quantile(dat$texture_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_t = IQR(dat$texture_mean)
up_t <-  Q_t[2]+1.5*iqr_t # Upper Range for texture
low_t<- Q_t[1]-1.5*iqr_t # Lower Range for texture
dat_m<- subset(dat_m, dat$radius_mean > (low_r) & dat$radius_mean < (up_r) & dat$texture_mean > (low_t) & dat$texture_mean < (up_t))
#split data
dat_m['randu'] <- c(runif(nrow(dat_m), 0, 1))
#training data
train_dat = dat_m %>% filter(randu <= 0.1)
#test data
test_dat = dat_m %>% filter(randu >= 0.1)
#train model
model <- glm (diag_ ~ radius_mean + texture_mean, data = train_dat, family = binomial)
#check coefficients
summary(model)
sprintf('Odds ratio : \n %s', paste(exp(coef(model)), collapse = ", ")) %>% writeLines()
#scatterplot
slope <- coef(model)[2]/(-coef(model)[3])
intercept <- coef(model)[1]/(-coef(model)[3])
xyplot(texture_mean ~ radius_mean , data = test_dat, groups = diag_,
panel=function(...){
panel.xyplot(...)
panel.abline(intercept , slope)
panel.grid(...)
})
#roc curve
pred_y = predict.glm(object = model, newdata = test_dat, type = "response")
pred_y
pred = prediction(predictions = pred_y, labels = test_dat$diag_)
roc_plot <- performance(pred,"tpr","fpr")
plot(roc_plot ,colorize=FALSE)
auc <- performance(pred, measure = "auc")
sprintf("AUC : %f", auc@y.values[[1]])
getwd()
getwd()
dat <- read_csv("./dataset/bdiag.csv")
getwd()
getwd()
setwd("D:/Saf")
getwd()
dat <- read_csv("./dataset/bdiag.csv")
library(readr)
library(ggplot2)
library(tidyverse)
library(lattice)
library(ROCR)
getwd()
dat <- read_csv("./dataset/bdiag.csv")
dat['diag_'] <- as.numeric(dat[c('diagnosis')] == 'M')
#View(dat)
dat_m <- dat[c('diag_', 'radius_mean', 'texture_mean')]
p1 = ggplot(data = dat, aes(fill = diagnosis, y = radius_mean))+geom_boxplot()
p2 = ggplot(data = dat, aes(fill = diagnosis, y = texture_mean))+geom_boxplot()
p1
p2
#removing outliers
Q_r = quantile(dat$radius_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_r = IQR(dat$radius_mean)
up_r <-  Q_r[2]+1.5*iqr_r # Upper Range for radius
low_r<- Q_r[1]-1.5*iqr_r # Lower Range for radius
Q_t = quantile(dat$texture_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_t = IQR(dat$texture_mean)
up_t <-  Q_t[2]+1.5*iqr_t # Upper Range for texture
low_t<- Q_t[1]-1.5*iqr_t # Lower Range for texture
dat_m<- subset(dat_m, dat$radius_mean > (low_r) & dat$radius_mean < (up_r) & dat$texture_mean > (low_t) & dat$texture_mean < (up_t))
#split data
dat_m['randu'] <- c(runif(nrow(dat_m), 0, 1))
#training data
train_dat = dat_m %>% filter(randu <= 0.1)
#test data
test_dat = dat_m %>% filter(randu >= 0.1)
#train model
model <- glm (diag_ ~ radius_mean + texture_mean, data = train_dat, family = binomial)
#check coefficients
summary(model)
sprintf('Odds ratio : \n %s', paste(exp(coef(model)), collapse = ", ")) %>% writeLines()
#scatterplot
slope <- coef(model)[2]/(-coef(model)[3])
intercept <- coef(model)[1]/(-coef(model)[3])
xyplot(texture_mean ~ radius_mean , data = test_dat, groups = diag_,
panel=function(...){
panel.xyplot(...)
panel.abline(intercept , slope)
panel.grid(...)
})
#roc curve
pred_y = predict.glm(object = model, newdata = test_dat, type = "response")
pred_y
pred = prediction(predictions = pred_y, labels = test_dat$diag_)
roc_plot <- performance(pred,"tpr","fpr")
plot(roc_plot ,colorize=FALSE)
auc <- performance(pred, measure = "auc")
sprintf("AUC : %f", auc@y.values[[1]])
library(readr)
library(ggplot2)
library(tidyverse)
library(lattice)
library(ROCR)
getwd()
dat <- read_csv("./dataset/bdiag.csv")
dat['diag_'] <- as.numeric(dat[c('diagnosis')] == 'M')
#View(dat)
dat_m <- dat[c('diag_', 'radius_mean', 'texture_mean')]
p1 = ggplot(data = dat, aes(fill = diagnosis, y = radius_mean))+geom_boxplot()
p2 = ggplot(data = dat, aes(fill = diagnosis, y = texture_mean))+geom_boxplot()
p1
p2
#removing outliers
Q_r = quantile(dat$radius_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_r = IQR(dat$radius_mean)
up_r <-  Q_r[2]+1.5*iqr_r # Upper Range for radius
low_r<- Q_r[1]-1.5*iqr_r # Lower Range for radius
Q_t = quantile(dat$texture_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_t = IQR(dat$texture_mean)
up_t <-  Q_t[2]+1.5*iqr_t # Upper Range for texture
low_t<- Q_t[1]-1.5*iqr_t # Lower Range for texture
dat_m<- subset(dat_m, dat$radius_mean > (low_r) & dat$radius_mean < (up_r) & dat$texture_mean > (low_t) & dat$texture_mean < (up_t))
#split data
dat_m['randu'] <- c(runif(nrow(dat_m), 0, 1))
#training data
train_dat = dat_m %>% filter(randu <= 0.1)
#test data
test_dat = dat_m %>% filter(randu >= 0.1)
#train model
model <- glm (diag_ ~ radius_mean + texture_mean, data = train_dat, family = binomial)
#check coefficients
summary(model)
sprintf('Odds ratio : \n %s', paste(exp(coef(model)), collapse = ", ")) %>% writeLines()
#scatterplot
slope <- coef(model)[2]/(-coef(model)[3])
intercept <- coef(model)[1]/(-coef(model)[3])
xyplot(texture_mean ~ radius_mean , data = test_dat, groups = diag_,
panel=function(...){
panel.xyplot(...)
panel.abline(intercept , slope)
panel.grid(...)
})
#roc curve
pred_y = predict.glm(object = model, newdata = test_dat, type = "response")
pred_y
pred = prediction(predictions = pred_y, labels = test_dat$diag_)
roc_plot <- performance(pred,"tpr","fpr")
plot(roc_plot ,colorize=FALSE)
str(roc_plot)
auc <- performance(pred, measure = "auc")
sprintf("AUC : %f", auc@y.values[[1]])
library(readr)
library(ggplot2)
library(tidyverse)
library(lattice)
library(ROCR)
getwd()
dat <- read_csv("./dataset/bdiag.csv")
dat['diag_'] <- as.numeric(dat[c('diagnosis')] == 'M')
#View(dat)
dat_m <- dat[c('diag_', 'radius_mean', 'texture_mean')]
p1 = ggplot(data = dat, aes(fill = diagnosis, y = radius_mean))+geom_boxplot()
p2 = ggplot(data = dat, aes(fill = diagnosis, y = texture_mean))+geom_boxplot()
p1
p2
#removing outliers
Q_r = quantile(dat$radius_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_r = IQR(dat$radius_mean)
up_r <-  Q_r[2]+1.5*iqr_r # Upper Range for radius
low_r<- Q_r[1]-1.5*iqr_r # Lower Range for radius
Q_t = quantile(dat$texture_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_t = IQR(dat$texture_mean)
up_t <-  Q_t[2]+1.5*iqr_t # Upper Range for texture
low_t<- Q_t[1]-1.5*iqr_t # Lower Range for texture
dat_m<- subset(dat_m, dat$radius_mean > (low_r) & dat$radius_mean < (up_r) & dat$texture_mean > (low_t) & dat$texture_mean < (up_t))
#split data
dat_m['randu'] <- c(runif(nrow(dat_m), 0, 1))
#training data
train_dat = dat_m %>% filter(randu <= 0.1)
#test data
test_dat = dat_m %>% filter(randu >= 0.1)
#train model
model <- glm (diag_ ~ radius_mean + texture_mean, data = train_dat, family = binomial)
#check coefficients
summary(model)
sprintf('Odds ratio : \n %s', paste(exp(coef(model)), collapse = ", ")) %>% writeLines()
#scatterplot
slope <- coef(model)[2]/(-coef(model)[3])
intercept <- coef(model)[1]/(-coef(model)[3])
xyplot(texture_mean ~ radius_mean , data = test_dat, groups = diag_,
panel=function(...){
panel.xyplot(...)
panel.abline(intercept , slope)
panel.grid(...)
})
#roc curve
pred_y = predict.glm(object = model, newdata = test_dat, type = "response")
pred_y
pred = prediction(predictions = pred_y, labels = test_dat$diag_)
roc_plot <- performance(pred,"tpr","fpr")
plot(roc_plot ,colorize=FALSE)
#get oprimal threshold
str(roc_plot)
cutoffs <- data.frame(cut=perf@alpha.values[[1]], fpr=perf@x.values[[1]],
tpr=perf@y.values[[1]])
head(cutoffs)
auc <- performance(pred, measure = "auc")
sprintf("AUC : %f", auc@y.values[[1]])
library(readr)
library(ggplot2)
library(tidyverse)
library(lattice)
library(ROCR)
getwd()
dat <- read_csv("./dataset/bdiag.csv")
dat['diag_'] <- as.numeric(dat[c('diagnosis')] == 'M')
#View(dat)
dat_m <- dat[c('diag_', 'radius_mean', 'texture_mean')]
p1 = ggplot(data = dat, aes(fill = diagnosis, y = radius_mean))+geom_boxplot()
p2 = ggplot(data = dat, aes(fill = diagnosis, y = texture_mean))+geom_boxplot()
p1
p2
#removing outliers
Q_r = quantile(dat$radius_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_r = IQR(dat$radius_mean)
up_r <-  Q_r[2]+1.5*iqr_r # Upper Range for radius
low_r<- Q_r[1]-1.5*iqr_r # Lower Range for radius
Q_t = quantile(dat$texture_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_t = IQR(dat$texture_mean)
up_t <-  Q_t[2]+1.5*iqr_t # Upper Range for texture
low_t<- Q_t[1]-1.5*iqr_t # Lower Range for texture
dat_m<- subset(dat_m, dat$radius_mean > (low_r) & dat$radius_mean < (up_r) & dat$texture_mean > (low_t) & dat$texture_mean < (up_t))
#split data
dat_m['randu'] <- c(runif(nrow(dat_m), 0, 1))
#training data
train_dat = dat_m %>% filter(randu <= 0.1)
#test data
test_dat = dat_m %>% filter(randu >= 0.1)
#train model
model <- glm (diag_ ~ radius_mean + texture_mean, data = train_dat, family = binomial)
#check coefficients
summary(model)
sprintf('Odds ratio : \n %s', paste(exp(coef(model)), collapse = ", ")) %>% writeLines()
#scatterplot
slope <- coef(model)[2]/(-coef(model)[3])
intercept <- coef(model)[1]/(-coef(model)[3])
xyplot(texture_mean ~ radius_mean , data = test_dat, groups = diag_,
panel=function(...){
panel.xyplot(...)
panel.abline(intercept , slope)
panel.grid(...)
})
#roc curve
pred_y = predict.glm(object = model, newdata = test_dat, type = "response")
pred_y
pred = prediction(predictions = pred_y, labels = test_dat$diag_)
roc_plot <- performance(pred,"tpr","fpr")
plot(roc_plot ,colorize=FALSE)
#get oprimal threshold
str(roc_plot)
cutoffs <- data.frame(cut=roc_plot@alpha.values[[1]], fpr=roc_plot@x.values[[1]],
tpr=roc_plot@y.values[[1]])
head(cutoffs)
auc <- performance(pred, measure = "auc")
sprintf("AUC : %f", auc@y.values[[1]])
library(readr)
library(ggplot2)
library(tidyverse)
library(lattice)
library(ROCR)
getwd()
dat <- read_csv("./dataset/bdiag.csv")
dat['diag_'] <- as.numeric(dat[c('diagnosis')] == 'M')
#View(dat)
dat_m <- dat[c('diag_', 'radius_mean', 'texture_mean')]
p1 = ggplot(data = dat, aes(fill = diagnosis, y = radius_mean))+geom_boxplot()
p2 = ggplot(data = dat, aes(fill = diagnosis, y = texture_mean))+geom_boxplot()
p1
p2
#removing outliers
Q_r = quantile(dat$radius_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_r = IQR(dat$radius_mean)
up_r <-  Q_r[2]+1.5*iqr_r # Upper Range for radius
low_r<- Q_r[1]-1.5*iqr_r # Lower Range for radius
Q_t = quantile(dat$texture_mean, probs=c(.25, .75), na.rm = FALSE)
iqr_t = IQR(dat$texture_mean)
up_t <-  Q_t[2]+1.5*iqr_t # Upper Range for texture
low_t<- Q_t[1]-1.5*iqr_t # Lower Range for texture
dat_m<- subset(dat_m, dat$radius_mean > (low_r) & dat$radius_mean < (up_r) & dat$texture_mean > (low_t) & dat$texture_mean < (up_t))
#split data
dat_m['randu'] <- c(runif(nrow(dat_m), 0, 1))
#training data
train_dat = dat_m %>% filter(randu <= 0.1)
#test data
test_dat = dat_m %>% filter(randu >= 0.1)
#train model
model <- glm (diag_ ~ radius_mean + texture_mean, data = train_dat, family = binomial)
#check coefficients
summary(model)
sprintf('Odds ratio : \n %s', paste(exp(coef(model)), collapse = ", ")) %>% writeLines()
#scatterplot
slope <- coef(model)[2]/(-coef(model)[3])
intercept <- coef(model)[1]/(-coef(model)[3])
xyplot(texture_mean ~ radius_mean , data = test_dat, groups = diag_,
panel=function(...){
panel.xyplot(...)
panel.abline(intercept , slope)
panel.grid(...)
})
#roc curve
pred_y = predict.glm(object = model, newdata = test_dat, type = "response")
pred_y
pred = prediction(predictions = pred_y, labels = test_dat$diag_)
roc_plot <- performance(pred,"tpr","fpr")
plot(roc_plot ,colorize=FALSE)
#get oprimal threshold
str(roc_plot)
cutoffs <- data.frame(cut=roc_plot@alpha.values[[1]], fpr=roc_plot@x.values[[1]],
tpr=roc_plot@y.values[[1]])
head(cutoffs)
auc <- performance(pred, measure = "auc")
sprintf("AUC : %f", auc@y.values[[1]])
head(cutoffs, 20)
head(subset(cutoffs, fpr < 0.2))
head(subset(cutoffs, fpr < 0.2), 30)
pred > 0.5
pred
pred
pred()
pred.lm()
auc <- performance(pred, measure = "auc")
pred_y
pred_y > 0.5
as_numeric(pred_y > 0.5)
as.numeric(pred_y > 0.5)
install.packages("pROC")
library(pROC)
#roc curve
pred_y = predict.glm(object = model, newdata = test_dat, type = "response")
roc_curve <- roc(response = pred_y)
roc_curve <- lrROC(test_dat$diag_ ~ pred_y)
roc_curve <- roc(test_dat$diag_ ~ pred_y, plot = TRUE, print.auc = TRUE)
roc_curve <- roc(test_dat$diag_ ~ pred_y, plot = TRUE, print.auc = TRUE,
legacy.axes = TRUE)
roc_curve <- roc(test_dat$diag_ ~ pred_y, plot = TRUE, print.auc = TRUE, legacy.axes = TRUE)
